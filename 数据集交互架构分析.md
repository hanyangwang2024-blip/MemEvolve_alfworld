# MemEvolve 框架中不同数据集的交互架构分析

## 一、核心设计理念

MemEvolve 框架采用**统一接口 + 数据集适配器**的设计模式，使得不同的数据集（GAIA、WebWalkerQA、xBench）能够通过统一的接口与内存系统交互。

## 二、统一的数据结构

### 1. TrajectoryData - 统一的内存输入接口

所有数据集最终都转换为 `TrajectoryData` 格式：

```python
@dataclass
class TrajectoryData:
    """数据结构用于内存摄入"""
    query: str                    # 原始问题
    trajectory: List[Dict[str, Any]]  # Agent执行轨迹（消息列表）
    result: Optional[Any] = None  # 任务结果
    metadata: Optional[Dict[str, Any]] = None  # 数据集特定的元数据
```

### 2. BaseMemoryProvider - 统一的内存提供者接口

所有内存系统都实现这个接口：

```python
class BaseMemoryProvider(ABC):
    @abstractmethod
    def provide_memory(self, request: MemoryRequest) -> MemoryResponse:
        """根据查询检索相关记忆"""
        pass
    
    @abstractmethod
    def take_in_memory(self, trajectory_data: TrajectoryData) -> tuple[bool, str]:
        """将轨迹数据存入内存系统"""
        pass
```

## 三、不同数据集的处理流程

### GAIA 数据集 (`run_flash_searcher_mm_gaia.py`)

**特点：**
- 多模态任务（图像、音频、文本、Excel等）
- 有难度级别（Level 1/2/3）
- 使用 `MMSearchAgent`（支持视觉、音频、文本工具）

**数据提取：**
```python
# 从 JSONL 文件读取
item = {
    "Question": "...",
    "Final answer": "...",
    "task_id": "...",
    "Level": "1/2/3",
    "file_name": "xxx.xlsx"
}

# 转换为 TrajectoryData
trajectory_data = TrajectoryData(
    query=item["Question"],
    trajectory=agent_messages,  # Agent执行消息
    result=result.get("agent_result"),
    metadata={
        "task_id": task_id,
        "status": "success",
        "is_correct": is_correct,
        "level": level,
        "full_query": question,  # 包含文件描述的完整问题
    }
)
```

**特殊处理：**
- 如果任务包含附件文件（`.zip`, `.xlsx`, `.mp3`等），会调用 `get_zip_description()` 或 `get_single_file_description()` 生成文件描述
- 使用 `lasj.judge_equivalence()` 进行答案判断

### WebWalkerQA 数据集 (`run_flash_searcher_webwalkerqa.py`)

**特点：**
- 网页导航任务
- 有难度级别（easy/medium/hard）
- 有语言（en/zh）、领域、问题类型等属性
- 使用 `SearchAgent`（仅支持网页搜索和爬取工具）

**数据提取：**
```python
# 从 JSONL 文件读取
item = {
    "question": "...",
    "answer": "...",
    "root_url": "https://...",
    "info": {
        "domain": "...",
        "difficulty_level": "easy/medium/hard",
        "lang": "en/zh",
        "type": "single_source/multi_source",
        "source_website": [...],
        "golden_path": [...]
    }
}

# 增强问题（添加导航指令）
enhanced_question = WEBWALKERQA_PROMPT_TEMPLATE.format(
    question=question,
    root_url=root_url
)

# 转换为 TrajectoryData
trajectory_data = TrajectoryData(
    query=question,  # 原始问题
    trajectory=agent_messages,
    result=result.get("agent_result"),
    metadata={
        "item_index": item_index,
        "status": "success",
        "is_correct": is_correct,
        "domain": domain,
        "difficulty": difficulty,
        "full_query": enhanced_question,  # 包含导航指令的完整问题
    }
)
```

**特殊处理：**
- 使用自定义的 `judge_webwalkerqa_answer()` 进行答案判断
- 支持按难度、语言、领域、问题类型过滤

### xBench 数据集 (`run_flash_searcher_mm_xbench.py`)

**特点：**
- 多模态深度搜索任务
- 数据加密存储（XOR加密）
- 使用 `MMSearchAgent`
- 使用中文LLM Judge

**数据提取：**
```python
# 从 CSV 文件读取并解密
with open(args.infile, 'r', encoding='utf-8-sig') as file:
    reader = csv.DictReader(file)
    for question in reader:
        key = question["canary"]
        question["prompt"] = xor_decrypt(
            base64.b64decode(question["prompt"]), 
            key
        ).decode('utf-8')
        question["answer"] = xor_decrypt(
            base64.b64decode(question["answer"]), 
            key
        ).decode('utf-8')

# 转换为 TrajectoryData
trajectory_data = TrajectoryData(
    query=question,
    trajectory=agent_messages,
    result=result.get("agent_result"),
    metadata={
        "task_id": task_id,
        "status": "success",
        "is_correct": is_correct,
        "full_query": question,
    }
)
```

**特殊处理：**
- 使用 `grade_question()` 进行评分（支持直接匹配和LLM判断）
- 输出包含 `score`, `extracted_answer`, `grader_explanation`

## 四、统一的内存交互流程

### 1. 内存提供者加载

所有数据集使用相同的加载逻辑：

```python
def load_memory_provider(memory_type_str, model=None):
    """加载并初始化内存提供者"""
    memory_type = MemoryType(memory_type_str)
    class_name, module_name = PROVIDER_MAPPING[memory_type]
    module = __import__(f"EvolveLab.providers.{module_name}", fromlist=[class_name])
    provider_class = getattr(module, class_name)
    config = get_memory_config(memory_type)
    if model is not None:
        config["model"] = model
    provider = provider_class(config=config)
    provider.initialize()
    return provider
```

### 2. 任务处理流程

所有数据集遵循相同的处理模式：

```python
def process_item(item, ...):
    # 1. 创建模型和Agent
    task_model = OpenAIServerModel(**model_config)
    memory_provider = load_memory_provider(memory_type_str, task_model)
    search_agent = SearchAgent/MMSearchAgent(
        task_model,
        memory_provider=memory_provider
    )
    
    # 2. 执行任务
    result = search_agent(question)
    agent_messages = search_agent.agent_fn.write_memory_to_messages()
    
    # 3. 判断答案正确性（数据集特定）
    is_correct = judge_answer(...)
    
    # 4. 存入内存系统（统一接口）
    if memory_provider and enable_memory_evolution:
        trajectory_data = TrajectoryData(
            query=original_question,
            trajectory=agent_messages,
            result=result.get("agent_result"),
            metadata={...}  # 数据集特定的元数据
        )
        memory_provider.take_in_memory(trajectory_data)
    
    # 5. 返回结果
    return task_result
```

### 3. 内存检索流程

Agent在执行过程中会调用内存提供者：

```python
# 在 Agent 内部，当需要记忆指导时
memory_request = MemoryRequest(
    query=current_query,
    context=current_context,
    status=MemoryStatus.BEGIN  # 或 MemoryStatus.IN
)
memory_response = memory_provider.provide_memory(memory_request)
# 使用 memory_response.memories 指导Agent决策
```

## 五、数据集特定的差异处理

### 1. Agent类型选择

- **GAIA & xBench**: 使用 `MMSearchAgent`（支持多模态工具）
- **WebWalkerQA**: 使用 `SearchAgent`（仅网页工具）

### 2. 答案判断方式

- **GAIA**: `lasj.judge_equivalence()` - 等价性判断
- **WebWalkerQA**: `judge_webwalkerqa_answer()` - 自定义判断逻辑
- **xBench**: `grade_question()` - 支持直接匹配和LLM判断

### 3. 元数据字段

每个数据集在 `TrajectoryData.metadata` 中存储不同的信息：

- **GAIA**: `task_id`, `level`, `status`, `is_correct`
- **WebWalkerQA**: `item_index`, `domain`, `difficulty`, `language`, `type`
- **xBench**: `task_id`, `status`, `is_correct`

### 4. 报告生成

使用统一的 `generate_unified_report()`，但传入不同的参数：

```python
# GAIA
generate_unified_report(
    results, report_path,
    dataset_name="GAIA",
    has_levels=True,
    level_key="level"
)

# WebWalkerQA
generate_unified_report(
    results, report_path,
    dataset_name="WebWalkerQA",
    has_levels=True,
    level_key="difficulty"
)

# xBench
generate_unified_report(
    results, report_path,
    dataset_name="XBench",
    has_levels=False
)
```

## 六、关键设计优势

1. **统一接口**: `TrajectoryData` 和 `BaseMemoryProvider` 使得不同数据集可以无缝使用相同的内存系统
2. **灵活适配**: 每个数据集可以有自己的数据格式、判断逻辑、过滤条件
3. **可扩展性**: 添加新数据集只需：
   - 创建新的运行脚本
   - 实现数据集特定的数据提取逻辑
   - 转换为 `TrajectoryData` 格式
   - 调用统一的内存接口
4. **内存系统无关**: 内存系统的实现细节对数据集透明，可以轻松切换不同的内存提供者

## 七、总结

MemEvolve 框架通过以下方式实现了不同数据集的统一交互：

1. **数据层**: 使用 `TrajectoryData` 作为统一的数据结构
2. **接口层**: 使用 `BaseMemoryProvider` 定义统一的内存操作接口
3. **适配层**: 每个数据集脚本负责将自身格式转换为统一格式
4. **执行层**: 使用相同的Agent框架和工具系统

这种设计使得框架既保持了统一性，又允许每个数据集保留其特定的处理逻辑，是一个很好的架构设计范例。
